{# Fields required for this template:

- class_name: str. The name of the class to be created
- inherits_from: str. The name of the class this class inherits from
- definition: Dict[str, str]. A dictionary of the fields and their types.
- defaults: Dict[str, str]. A dictionary of the fields and their default values. If no default value is specified, the field is required.
- imports: Dict[str, str]. A dictionary of the imports to be added to the file. The key is the name of the import, the value is the import itself.

#}

# The following file has been created automatically based on a jinja template
# Anything you modify to it, will get lost when the next time the template is
# created. If you want to modify the class, please do so in the template
#
# Template has been rendered

{# Dict of required keys-vals, these have no defaults so they need to be handled differently #}
{% set required = {} %}

import uuid
import tomlkit

from pathlib import Path
from typing import List, Tuple, Dict, Optional, Union
{% for key, val in imports.items() -%}
{{ val }} as {{ key }}
{% endfor %}

from qdata.utils import create_timestamp
from qdata.components.comment import Comment


class {{class_name}}({{ inherits_from }}):
    def __init__(self,
                 {% for key, val in definition.items() -%}
                 {# This is to check what items should not have default and need to come before any other argument #}
                 {%- if key not in defaults -%}
                 {{ key }}: {{ val }},
                 {% do required.update({key: val}) -%}
                 {% endif -%}
                 {% endfor -%}
                 {% for key in required.keys() -%}
                 {% do definition.pop(key) -%}
                 {% endfor -%}
                 {% for key, val in definition.items() -%}
                 {% if 'time' in key -%}
                 {{ key }}: str = None,
                 {% else -%}
                 {{ key }}: {{ val }} = {{ defaults[key] }},
                 {% endif -%}
                 {% endfor -%}
                 {% if class_name != 'Entity' -%}
                 *args, **kwargs
                 {% endif -%}
    ):
        {% if class_name != 'Entity' -%}
        super().__init__(*args, **kwargs)
        {% endif -%}
        {% for key, val in required.items() -%}
        self.{{ key }} = {{ key }}
        {% endfor -%}
        {% for key in definition.keys() -%}
        {% if 'time' in key -%}

        if {{ key }} is None or {{ key }} == '':
            self.{{ key }} = create_timestamp()
        else:
            self.{{ key }} = {{ key }}

        {% elif "ID" in key -%}
        if {{ key }} is None or {{ key }} == '':
            self.{{ key }} = str(uuid.uuid4())
        else:
            self.{{ key }} = {{ key }}

        {% elif 'name' in key -%}
        if {{ key }} is None or {{ key }} == '':
            self.{{ key }} = self.ID
        else:
            self.{{ key }} = {{ key }}

        {% elif 'comment' in key -%}
        if isinstance({{ key }}, list) and len({{ key }}) != 0:
            self.{{ key }} = []
            for com in {{ key }}:
                if isinstance(com, Comment):
                    self.{{ key }}.append(com)
                else:
                    self.{{ key }}.append(Comment(com, user))
        else:
            self.{{ key }} = [].copy()

        {% elif not defaults[key] is string and defaults[key] is iterable -%}
        # If we don't save a copy of the list,
        #   python ends up assigning the same object in memory to every Entity instance.
        if isinstance({{ key }}, list) and len({{ key }}) != 0:
            self.{{ key }} = {{ key }}
        else:
            self.{{ key }} = [].copy()
        {% else -%}

        self.{{ key }} = {{ key }}
        {% endif -%}
        {% endfor %}
    def to_TOML(self, path: Optional[Union[str,Path]] = None):

        if hasattr(super(), 'to_TOML'):
            doc = super().to_TOML()
            vals = doc[self.name]
        else:
            doc = tomlkit.document()
            vals = tomlkit.table()

        vals['type'] = self.__class__.__name__
        {% for key, val in required.items() -%}
        vals['{{ key }}'] = self.{{ key }}
        {% endfor -%}
        {% for key in definition.keys() -%}
        {% if 'children' in key -%}
        # We want to save the str version of every child, not the object.
        vals['{{ key }}'] = [str(child) for child in self.{{ key }}]
        {% elif 'parent' in key -%}
        vals['{{ key }}'] = str(self.{{ key }})
        {% elif 'comment' in key -%}
        # Same as children, we want to save the str version of every comment, not the object.
        vals['{{ key }}'] = [str(comment) for comment in self.{{ key }}]
        {% else -%}
        vals['{{ key }}'] = self.{{ key }}
        {% endif %}
        {% endfor %}
        doc[self.name] = vals

        if path is not None:
            path = Path(path)
            if path.is_dir():
                path = path.joinpath(self.name + '.toml')
            with open(path, 'w') as f:
                f.write(doc.as_string())

        return doc

    def __str__(self):
        return str(self.to_TOML())

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return False

    {# Only add the add_children method for the Entity class and no other one. #}
    {% if class_name == 'Entity' -%}
    def add_child(self, child):
        if not hasattr(self, 'children'):
            self.children = []
        self.children.append(child)

    def add_comment(self, comment: Union[str, List[str]], user: Optional[str], uuid: Optional[str]):
        """
        Add a comment to the entity with the proper metadata. By specifying the user,
        a comment can be written by a different user.

        The structure
        """
        raise NotImplementedError
    {% endif %}
