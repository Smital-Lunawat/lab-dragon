{# Fields required for this template:

- class_name: str. The name of the class to be created
- inherits_from: str. The name of the class this class inherits from
- definition: Dict[str, str]. A dictionary of the fields and their types.
- defaults: Dict[str, str]. A dictionary of the fields and their default values. If no default value is specified, the field is required.
- imports: Dict[str, str]. A dictionary of the imports to be added to the file. The key is the name of the import, the value is the import itself.

#}

# The following file has been created automatically based on a jinja template
# Anything you modify to it, will get lost when the next time the template is
# created. If you want to modify the class, please do so in the template
#
# Template has been rendered

{# Dict of required keys-vals, these have no defaults so they need to be handled differently #}
{% set required = {} %}

import uuid
import tomlkit

from pathlib import Path
from typing import List, Tuple, Dict, Optional, Union
{% for key, val in imports.items() -%}
{{ val }} as {{ key }}
{% endfor %}

from qdata.utils import create_timestamp
from qdata.components.comment import Comment, SupportedCommentType


class {{class_name}}({{ inherits_from }}):
    def __init__(self,
                 {% for key, val in definition.items() -%}
                 {# This is to check what items should not have default and need to come before any other argument #}
                 {%- if key not in defaults -%}
                 {{ key }}: {{ val }},
                 {% do required.update({key: val}) -%}
                 {% endif -%}
                 {% endfor -%}
                 {% for key in required.keys() -%}
                 {% do definition.pop(key) -%}
                 {% endfor -%}
                 {% for key, val in definition.items() -%}
                 {% if 'time' in key -%}
                 {{ key }}: str = None,
                 {% else -%}
                 {{ key }}: {{ val }} = {{ defaults[key] }},
                 {% endif -%}
                 {% endfor -%}
                 {% if class_name != 'Entity' -%}
                 *args, **kwargs
                 {% endif -%}
    ):
        {% if class_name != 'Entity' -%}
        super().__init__(*args, **kwargs)
        {% endif -%}
        {% for key, val in required.items() -%}
        self.{{ key }} = {{ key }}
        {% endfor -%}
        {% for key in definition.keys() -%}
        {% if 'time' in key -%}

        if {{ key }} is None or {{ key }} == '':
            self.{{ key }} = create_timestamp()
        else:
            self.{{ key }} = {{ key }}

        {% elif "ID" in key -%}
        if {{ key }} is None or {{ key }} == '':
            self.{{ key }} = str(uuid.uuid4())
        else:
            self.{{ key }} = {{ key }}

        {% elif 'name' in key -%}
        if {{ key }} is None or {{ key }} == '':
            self.{{ key }} = self.ID
        else:
            self.{{ key }} = {{ key }}

        {% elif 'comment' in key -%}
        if isinstance({{ key }}, list) and len({{ key }}) != 0:
            self.{{ key }} = []
            for com in {{ key }}:
                self.add_comment(com)
        else:
            self.{{ key }} = [].copy()

        {% elif not defaults[key] is string and defaults[key] is iterable -%}
        # If we don't save a copy of the list,
        #   python ends up assigning the same object in memory to every Entity instance.
        if isinstance({{ key }}, list) and len({{ key }}) != 0:
            self.{{ key }} = {{ key }}
        else:
            self.{{ key }} = [].copy()
        {% else -%}

        self.{{ key }} = {{ key }}
        {% endif -%}
        {% endfor %}
    def to_TOML(self, path: Optional[Union[str,Path]] = None):

        if hasattr(super(), 'to_TOML'):
            doc = super().to_TOML()
            vals = doc[self.name]
        else:
            doc = tomlkit.document()
            vals = tomlkit.table()

        vals['type'] = self.__class__.__name__
        {% for key, val in required.items() -%}
        vals['{{ key }}'] = self.{{ key }}
        {% endfor -%}
        {% for key in definition.keys() -%}
        {% if 'children' in key -%}
        # We want to save the str version of every child, not the object.
        vals['{{ key }}'] = [str(child) for child in self.{{ key }}]
        {% elif 'parent' in key -%}
        vals['{{ key }}'] = str(self.{{ key }})
        {% elif 'comment' in key -%}
        # Same as children, we want to save the str version of every comment, not the object.
        vals['{{ key }}'] = [str(comment) for comment in self.{{ key }}]
        {% else -%}
        vals['{{ key }}'] = self.{{ key }}
        {% endif %}
        {% endfor %}
        doc[self.name] = vals

        if path is not None:
            path = Path(path)
            if path.is_dir():
                path = path.joinpath(self.name + '.toml')
            with open(path, 'w') as f:
                f.write(doc.as_string())

        return doc

    def __str__(self):
        return str(self.to_TOML())

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return False

    {# Only add the add_children method for the Entity class and no other one. #}
    {% if class_name == 'Entity' -%}
    def add_child(self, child):
        if not hasattr(self, 'children'):
            self.children = []
        self.children.append(child)

    def add_comment(self, comment: Union[str, Comment, List[Comment], List[str]], user: Optional[str] = None) -> None:
        """
        Add a comment to the entity. If a directory is passed, this function will go through the directory and add a
        comment to every supported file in it in alphabetical order. It will **NOT** go through subdirectories.
        Whenever it iterates through a list (either if it is passed a list or goes through all of the files in a
        directory) it will call itself to add individual comments.

        :param comment: If passed a string to indicate the comment, it will create a new `Comment` object with that
            string as the comment. If its passed a list of strings, it will create a new comment for each of those strings.
            If passed a `Comment` object, it will add that comment to the entity. If passed a list of `Comment` objects,
            it will add each of those comments to the entity.
        :param user: The user that is adding the comment.
            If not passed, it will default to the use who created this entity.
        """

        # Function inside function because its very specific to adding comments and should not be called from anywhere else
        def add_directory(path: Path) -> None:
            files = [file for file in path.iterdir() if file.is_file()]
            supported_items = SupportedCommentType.__members__.keys()
            for file in sorted(files):
                if file.is_dir():
                    continue
                if file.suffix[1:] in supported_items:
                    self.add_comment(Comment(file, user))
                else:
                    continue

        if user is None:
            user = self.user

        if isinstance(comment, list):
            for com in comment:
                if isinstance(com, Comment):
                    self.comments.append(com)
                else:
                    self.add_comment(com, user)
        else:
            if isinstance(comment, Comment):
                self.comments.append(comment)
            elif isinstance(comment, str):
                try:
                    path = Path(comment)
                    if path.is_dir():
                        add_directory(path)
                    else:
                        self.comments.append(Comment(comment, user))
                # Comment may be too long to convert to path
                except OSError:
                    self.comments.append(Comment(comment, user))
            else:
                raise TypeError(f"Comment must be a string or a Comment object, not {type(comment)}")

    {% endif %}
